using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using kwh.Models;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;
using Microsoft.EntityFrameworkCore;

// Tutorial from https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/sort-filter-page?view=aspnetcore-3.1
namespace kwh.Pages.Inventory
{
    public class IndexModel : PageModel
    {
        private readonly kwhDataContext _context;

        public IndexModel(kwhDataContext context)
        {
            _context = context;
        }

        // Add properties to contain searching and filtering parameters
        [BindProperty]
        public string SearchBy { get; set; }
        public string[] Criteria = new[] { "Category", "Part", "Project" };
        public string CurrentFilter { get; set; }

        // Add properties to contain sorting parameters
        public string NameSort { get; set; }
        public string QuantitySort { get; set; }
        public string CostSort { get; set; }
        public string ProjectSort { get; set; }
        public string CategorySort { get; set; }
        public string CurrentSort { get; set; }

        public IList<Component> Component { get; set; }

        // For exporting Excel files
        public IQueryable<Component> c_list { get; set; }

        /* Receives sortOrder, currentFilter, searchBy criteria, searchString
         * and pageIndex from the query string in the URL. (The URL and query
         * string is generated by the Anchor Tag Helper.)
         */
        public async Task OnGetAsync(string sortOrder, string currentFilter
            , string searchby, string searchString)
        {
            CurrentSort = sortOrder;

            /* The sortOrder is either Name, Quantity, Cost, Project, or
             * Category. The default sort order is ascending and "_desc"
             * specifies descending order. When the Index page is requested, the
             * query string is empty, so the components are defaulted to display
             * in ascending order by PartName.
             */
            NameSort = String.IsNullOrEmpty(sortOrder) ? "name_desc" : "";
            QuantitySort = sortOrder == "Quantity" ? "quan_desc" : "Quantity";
            CostSort = sortOrder == "Cost" ? "cost_desc" : "Cost";
            ProjectSort = sortOrder == "Project" ? "proj_desc" : "Project";
            CategorySort = sortOrder == "Category" ? "cat_desc" : "Category";

            if (searchString == null)
            {
                searchString = currentFilter;
            }

            CurrentFilter = searchString;
            SearchBy = searchby;

            /* Selects all from Component table. IQueryable allows flexibility
             * to add onto that query below...
             *
             * When an IQueryable is created or modified, no query is sent to
             * the database. The query isn't executed until the IQueryable
             * object is converted into a collection.
             *
             * ** EF Core LINQ-to-Entities Queries (written in method syntax) **
             */
            IQueryable<Component> components = _context.Component;

            // User may search by Category, PartName, or Project. The
            // appropriate searchBy query is sent to the database. ".ToUpper()"
            // is used for case-sensitivity.
            if (!String.IsNullOrEmpty(searchString))
            {
                if (searchby == "Category")
                {
                    components = components
                        .Where(c => c.Category.CategoryName.ToUpper().Contains(searchString.ToUpper()));

                } else if (searchby == "Part")
                {
                    components = components
                        .Where(c => c.PartName.ToUpper().Contains(searchString.ToUpper())
                        || c.PartNumber.ToUpper().Contains(searchString.ToUpper()));
                } else
                {
                    components = components
                        .Where(c => c.Project.ProjectName.ToUpper().Contains(searchString.ToUpper()));
                }
            }

            /*Order should be
             .Where()
             .GroupBy(c => c.ComponentId)
             .Select(o => o.OrderByDescending(t => t.Timestamp).FirstOrDefault())
             .OrderBy()
            */

            /* Ascending order by PartName is the default. When the user clicks
             * a column heading link, the appropriate sortOrder value is
             * provided in the query string value.
             */
            switch (sortOrder)
            {
                case "name_desc":
                    components = components
                        .OrderByDescending(c => c.PartName);
                    break;
                case "Quantity":
                    components = components
                        .OrderBy(c => c.QuantityCurrent);
                    break;
                case "quan_desc":
                    components = components
                        .OrderByDescending(c => c.QuantityCurrent);
                    break;
                case "Cost":
                    components = components
                        .OrderBy(c => c.UnitCost);
                    break;
                case "cost_desc":
                    components = components
                        .OrderByDescending(c => c.UnitCost);
                    break;
                case "Project":
                    components = components
                        .OrderBy(c => c.Project.ProjectName);
                    break;
                case "proj_desc":
                    components = components
                        .OrderByDescending(c => c.Project.ProjectName);
                    break;
                case "Category":
                    components = components
                        .OrderBy(c => c.Category.CategoryName);
                    break;
                case "cat_desc":
                    components = components
                        .OrderByDescending(c => c.Category.CategoryName);
                    break;
                default:
                    components = components
                        .OrderBy(c => c.PartName);
                    break;
            }

            c_list = components;

            /* IQueryable are converted to a collection by calling a method such
             * as ToListAsync. Therefore, the IQueryable code above results in a
             * single query that's not executed until the following statement:
             */

            Component = await components
                .Include(c => c.Maturity)
                .Include(c => c.Project)
                .Include(c => c.Vendor)
                .Include(c => c.Volunteer)
                .Include(c => c.Category).AsNoTracking()
                .ToListAsync();
        }
    }
}


