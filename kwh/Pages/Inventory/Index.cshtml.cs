using System;
using System.Linq;
using System.Threading.Tasks;
using kwh.Models;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;
using Microsoft.EntityFrameworkCore;
using OfficeOpenXml;
using OfficeOpenXml.Style;
using System.IO;
using System.Drawing;

// Tutorial from https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/sort-filter-page?view=aspnetcore-3.1
namespace kwh.Pages.Inventory
{
    public class IndexModel : PageModel
    {
        private readonly kwhDataContext _context;

        public IndexModel(kwhDataContext context)
        {
            _context = context;
        }

        // Add properties to contain searching and filtering parameters
        [BindProperty]
        public string SearchBy { get; set; }
        public string[] Criteria = new[] { "Category", "Part", "Project" };
        public string CurrentFilter { get; set; }
        public string CurrentSort { get; set; }

        // Add properties to contain sorting parameters
        public string NameSort { get; set; }
        public string QuantitySort { get; set; }
        public string CostSort { get; set; }
        public string ProjectSort { get; set; }
        public string CategorySort { get; set; }

        // Derives PaginatedList to allow paging through
        public PaginatedList<Component> Component { get; set; }

        // For exporting Excel files
        public IQueryable<Component> c_list { get; set; }

        /* Receives sortOrder, currentFilter, searchBy criteria, searchString
         * and pageIndex from the query string in the URL. (The URL and query
         * string is generated by the Anchor Tag Helper.)
         */
        public async Task OnGetAsync(string sortOrder, string currentFilter
            , string searchby, string searchString, int? pageIndex)
        {
            CurrentSort = sortOrder;

            /* The sortOrder is either Name, Quantity, Cost, Project, or
             * Category. The default sort order is ascending and "_desc"
             * specifies descending order. When the Index page is requested, the
             * query string is empty, so the components are defaulted to display
             * in ascending order by PartName.
             */
            NameSort = String.IsNullOrEmpty(sortOrder) ? "name_desc" : "";
            QuantitySort = sortOrder == "Quantity" ? "quan_desc" : "Quantity";
            CostSort = sortOrder == "Cost" ? "cost_desc" : "Cost";
            ProjectSort = sortOrder == "Project" ? "proj_desc" : "Project";
            CategorySort = sortOrder == "Category" ? "cat_desc" : "Category";

            if (searchString != null)
            {
                pageIndex = 1;
            }
            else
            {
                searchString = currentFilter;
            }

            CurrentFilter = searchString;
            SearchBy = searchby;

            /* Selects all from Component table. IQueryable allows flexibility
             * to add onto that query below...
             *
             * When an IQueryable is created or modified, no query is sent to
             * the database. The query isn't executed until the IQueryable
             * object is converted into a collection.
             *
             * ** EF Core LINQ-to-Entities Queries (written in query syntax) **
             */
            IQueryable<Component> components = _context.Component;

            // User may search by Category, PartName, or Project. The
            // appropriate searchBy query is sent to the database. ".ToUpper()"
            // is used for case-sensitivity.
            if (!String.IsNullOrEmpty(searchString))
            {
                if (searchby == "Category")
                {
                    components = components
                        .Where(c => c.Category.CategoryName.ToUpper().Contains(searchString.ToUpper()));

                } else if (searchby == "Part")
                {
                    components = components
                        .Where(c => c.PartName.ToUpper().Contains(searchString.ToUpper())
                        || c.PartNumber.ToUpper().Contains(searchString.ToUpper()));
                } else
                {
                    components = components
                        .Where(c => c.Project.ProjectName.ToUpper().Contains(searchString.ToUpper()));
                }
            }

            /*Order should be
             .Where()
             .GroupBy(c => c.ComponentId)
             .Select(o => o.OrderByDescending(t => t.Timestamp).FirstOrDefault())
             .OrderBy()
            */
             // https://stackoverflow.com/questions/5013710/linq-order-by-group-by-and-order-by-each-group
             // https://www.thinktecture.com/en/entity-framework-core/hidden-group-by-capabilities-in-3-0-part-1/


            /* Ascending order by PartName is the default. When the user clicks
             * a column heading link, the appropriate sortOrder value is
             * provided in the query string value.
             */
            switch (sortOrder)
            {
                case "name_desc":
                    components = components
                        .OrderByDescending(c => c.PartName);
                    break;
                case "Quantity":
                    components = components
                        .OrderBy(c => c.QuantityCurrent);
                    break;
                case "quan_desc":
                    components = components
                        .OrderByDescending(c => c.QuantityCurrent);
                    break;
                case "Cost":
                    components = components
                        .OrderBy(c => c.UnitCost);
                    break;
                case "cost_desc":
                    components = components
                        .OrderByDescending(c => c.UnitCost);
                    break;
                case "Project":
                    components = components
                        .OrderBy(c => c.Project.ProjectName);
                    break;
                case "proj_desc":
                    components = components
                        .OrderByDescending(c => c.Project.ProjectName);
                    break;
                case "Category":
                    components = components
                        .OrderBy(c => c.Category.CategoryName);
                    break;
                case "cat_desc":
                    components = components
                        .OrderByDescending(c => c.Category.CategoryName);
                    break;
                default:
                    components = components
                        .OrderBy(c => c.PartName);
                    break;
            }

            c_list = components;

            /* IQueryable are converted to a collection by calling a method such
             * as ToListAsync. Therefore, the IQueryable code above results in a
             * single query that's not executed until the following statement:
             */

            int pageSize = 10; // Number of records shown per page
            Component = await PaginatedList<Component>.CreateAsync(
                components
                .Include(c => c.Maturity)
                .Include(c => c.Project)
                .Include(c => c.Vendor)
                .Include(c => c.Volunteer)
                .Include(c => c.Category).AsNoTracking(),
                pageIndex ?? 1, pageSize);
        }

        //FileResult or FileContentResult or IActionResult
        public IActionResult ExportExcel()
        {
            // Array holds column headers
            string[] headers = new string[]
            {
                "Component ID", "Part Number", "Part Name", "Category", "Vendor",
                "Unit Cost", "Notes", "Maturity", "Url", "Current Quan.",
                "Quan. Needed", "Project", "Volunteer"
            };

            // Grab records from MySql db
            var comp_list = c_list
                    .Include(c => c.Maturity)
                    .Include(c => c.Project)
                    .Include(c => c.Vendor)
                    .Include(c => c.Volunteer)
                    .Include(c => c.Category).ToList();

            // Convert the excel package to a byte array
            byte[] result;
            var stream = new MemoryStream();
            ExcelPackage.LicenseContext = LicenseContext.NonCommercial;
            using (ExcelPackage package = new ExcelPackage())
            {
                // Create new worksheet to empty workbook
                ExcelWorksheet ws = package.Workbook.Worksheets.Add("Inventory");

                // Style and populate header row
                for (int i = 0; i < headers.Length; i++)
                {
                    ws.Cells[1, i + 1].Style.Font.Size = 14;
                    ws.Cells[1, i + 1].Style.Font.Bold = true;
                    ws.Cells[1, i + 1].Style.Fill.PatternType = ExcelFillStyle.Solid;
                    ws.Cells[1, i + 1].Style.Font.Color.SetColor(Color.FromArgb(255, 255, 255));
                    ws.Cells[1, i + 1].Style.Fill.BackgroundColor.SetColor(Color.FromArgb(0, 0, 0));
                    ws.Cells[1, i + 1].Value = headers[i];
                }

                int row = 2;
                foreach (var item in comp_list)
                {
                    // Alternate row background colors for readability
                    if (row % 2 == 0)
                    {
                        ws.Row(row).Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                        ws.Row(row).Style.Fill.BackgroundColor.SetColor(Color.FromArgb(201, 201, 201));
                    }
                    // Populate data cells
                    for (int col = 1; col <= headers.Length; col++)
                    {
                        ws.Cells[row, col].Style.Font.Size = 12;
                    }
                    ws.Cells[row, 1].Value = item.ComponentId;
                    ws.Cells[row, 2].Value = item.PartNumber;
                    ws.Cells[row, 3].Value = item.PartName;
                    ws.Cells[row, 4].Value = item.Category.CategoryName;
                    ws.Cells[row, 5].Value = item.Vendor.VendorName;
                    ws.Cells[row, 6].Value = item.UnitCost;
                    ws.Cells[row, 7].Value = item.Notes;
                    ws.Cells[row, 8].Value = item.Maturity.MaturityStatus;
                    ws.Cells[row, 9].Value = item.Url;
                    ws.Cells[row, 10].Value = item.QuantityCurrent;
                    ws.Cells[row, 11].Value = item.QuantityNeeded;
                    ws.Cells[row, 12].Value = item.Project.ProjectName;
                    ws.Cells[row, 13].Value = item.Volunteer.LastName;

                    row++;
                }
                ws.Cells.AutoFitColumns();

                // Convert Excel sheet into byte array
                result = package.GetAsByteArray();
                package.SaveAs(stream);
                stream.Seek(0, SeekOrigin.Begin);
                package.Dispose();
            }
            string fileName = "Inventory-" + DateTime.Now.ToString("yyyyMMddTHHmmss") + ".xlsx";
            string mimeType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
            // Ommitting filename triggers inline content disposition, opening it
            // Including triggers attachment, saving the file 
            return File(
                stream,
                contentType: mimeType,
                fileDownloadName: fileName
            );
        }
    }
}


